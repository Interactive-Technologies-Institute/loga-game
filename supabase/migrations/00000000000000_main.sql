-- ===========================================
-- CUSTOM TYPES
-- ===========================================
CREATE TYPE public.stop_type AS ENUM (
    'nature',
    'sense',
    'action',
    'history',
    'landmark'
);
CREATE TYPE public.game_state AS ENUM (
    'waiting',
    'ready',
    'starting',
    'playing',
    'finished'
);
CREATE TYPE public.character_type AS ENUM (
    -- Human characters
    'child',
    'different-needs',
    'local-specialist',
    'nature-lover',
    'scientist',
    'time-traveller',
    
    -- Non-human characters
    'trocaz-pigeon',
    'monk-seal',
    'vulcanic-rock',
    'iberian-green-frog',
    'zinos-petrel',
    'water'
);
-- ===========================================
-- TABLE DEFINITIONS
-- ===========================================
-- Game elements tables
CREATE TABLE public.rounds (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    index INT NOT NULL,
    title VARCHAR(50) NOT NULL,
    description TEXT NOT NULL
);
CREATE TABLE public.stops (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type stop_type NOT NULL,
    initial BOOLEAN NOT NULL DEFAULT FALSE,
    name VARCHAR(50),
    x FLOAT NOT NULL,
    y FLOAT NOT NULL,
    paths INT [] NOT NULL
);
CREATE TABLE public.cards (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type stop_type NOT NULL,
    title VARCHAR(50),
    text TEXT NOT NULL
);
-- Core game tables
CREATE TABLE public.games (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    inserted_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    code VARCHAR(10) UNIQUE NOT NULL,
    state game_state NOT NULL DEFAULT 'waiting'
);
ALTER PUBLICATION supabase_realtime
ADD TABLE public.games;
CREATE TABLE public.players (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    inserted_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    character character_type,
    nickname VARCHAR(50),
    description TEXT,
    is_owner BOOLEAN NOT NULL DEFAULT FALSE,
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    game_id BIGINT REFERENCES public.games(id) ON DELETE CASCADE NOT NULL,
    UNIQUE (user_id, game_id),
    UNIQUE (character, game_id)
);
ALTER PUBLICATION supabase_realtime
ADD TABLE public.players;
-- Game progress tracking tables
CREATE TABLE public.player_moves (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    game_id BIGINT REFERENCES public.games(id) ON DELETE CASCADE NOT NULL,
    player_id BIGINT REFERENCES public.players(id) ON DELETE CASCADE NOT NULL,
    stop_id INT NOT NULL,
    round INT NOT NULL,
    UNIQUE (game_id, player_id, round)
);
ALTER PUBLICATION supabase_realtime
ADD TABLE public.player_moves;
CREATE TABLE public.player_cards (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    game_id BIGINT REFERENCES public.games(id) ON DELETE CASCADE NOT NULL,
    player_id BIGINT REFERENCES public.players(id) ON DELETE CASCADE NOT NULL,
    card_id INT NOT NULL,
    round INT NOT NULL,
    UNIQUE (game_id, player_id, round)
);
ALTER PUBLICATION supabase_realtime
ADD TABLE public.player_cards;
CREATE TABLE public.player_answers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    game_id BIGINT REFERENCES public.games(id) ON DELETE CASCADE NOT NULL,
    player_id BIGINT REFERENCES public.players(id) ON DELETE CASCADE NOT NULL,
    answer TEXT NOT NULL,
    round INT NOT NULL,
    UNIQUE (game_id, player_id, round)
);
ALTER PUBLICATION supabase_realtime
ADD TABLE public.player_answers;
CREATE TABLE public.game_rounds (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    game_id BIGINT REFERENCES public.games(id) ON DELETE CASCADE NOT NULL,
    round INT NOT NULL,
    dice_roll INT NOT NULL
);
ALTER PUBLICATION supabase_realtime
ADD TABLE public.game_rounds;
-- ===========================================
-- game MANAGEMENT FUNCTIONS
-- ===========================================
-- Creates a new game and assigns the owner
CREATE TYPE public.create_game_result AS (game_id BIGINT, game_code VARCHAR);
CREATE OR REPLACE FUNCTION public.create_game() RETURNS public.create_game_result LANGUAGE plpgsql AS $$
DECLARE generated_code VARCHAR;
result public.create_game_result;
BEGIN -- Generate a random unique game code
LOOP generated_code := LEFT(MD5(RANDOM()::TEXT), 6);
IF NOT EXISTS (
    SELECT 1
    FROM public.games
    WHERE code = generated_code
) THEN EXIT;
END IF;
END LOOP;
-- Create the game
INSERT INTO public.games (code, state)
VALUES (generated_code, 'waiting')
RETURNING id,
    code INTO result.game_id,
    result.game_code;
-- Add the owner as the first player
INSERT INTO public.players (is_owner, user_id, game_id)
VALUES (TRUE, auth.uid(), result.game_id);
RETURN result;
END;
$$;
-- Allows a player to join an existing game
CREATE OR REPLACE FUNCTION public.join_game(game_code VARCHAR) RETURNS VOID LANGUAGE plpgsql AS $$
DECLARE v_game_id BIGINT;
v_current_state game_state;
BEGIN -- Fetch the game ID and current state
SELECT id,
    state INTO v_game_id,
    v_current_state
FROM public.games
WHERE code = game_code;
-- Ensure the game exists
IF NOT FOUND THEN RAISE EXCEPTION 'game-not-found';
END IF;
-- Disallow joining if the game state is not 'waiting' or 'ready'
IF v_current_state NOT IN ('waiting', 'ready') THEN RAISE EXCEPTION 'game-already-started';
END IF;
-- Add the player to the game
INSERT INTO public.players (user_id, game_id)
VALUES (auth.uid(), v_game_id);
-- Check if all players are ready
PERFORM public.check_all_players_ready(v_game_id);
END;
$$;
-- ===========================================
-- PLAYER MANAGEMENT FUNCTIONS
-- ===========================================
-- Updates a player's character
CREATE OR REPLACE FUNCTION public.update_player_character(
        game_code VARCHAR,
        player_character character_type
    ) RETURNS VOID LANGUAGE plpgsql AS $$
DECLARE v_game_id BIGINT;
BEGIN
SELECT id INTO v_game_id
FROM public.games
WHERE code = game_code;
IF EXISTS (
    SELECT 1
    FROM public.players
    WHERE game_id = v_game_id
        AND character = player_character
) THEN RAISE EXCEPTION 'character-already-taken';
END IF;
UPDATE public.players
SET character = player_character
WHERE user_id = auth.uid()
    AND game_id = v_game_id;
-- Check if all players are ready
PERFORM public.check_all_players_ready(v_game_id);
END;
$$;
-- Updates a player's nickname and description
CREATE OR REPLACE FUNCTION public.update_player_nickname_description(
        game_code VARCHAR,
        player_nickname VARCHAR,
        player_description TEXT
    ) RETURNS VOID LANGUAGE plpgsql AS $$
DECLARE v_game_id BIGINT;
BEGIN
SELECT id INTO v_game_id
FROM public.games
WHERE code = game_code;
UPDATE public.players
SET nickname = player_nickname,
    description = player_description
WHERE user_id = auth.uid()
    AND game_id = v_game_id;
-- Check if all players are ready
PERFORM public.check_all_players_ready(v_game_id);
END;
$$;
-- ===========================================
-- GAME FLOW FUNCTIONS
-- ===========================================
-- Validates if all players are ready to start
CREATE OR REPLACE FUNCTION public.check_all_players_ready(p_game_id BIGINT) RETURNS VOID LANGUAGE plpgsql AS $$ BEGIN IF EXISTS (
        SELECT 1
        FROM public.players
        WHERE game_id = p_game_id
            AND (
                character IS NULL
                OR nickname IS NULL
                OR description IS NULL
            )
    ) THEN
UPDATE public.games
SET state = 'waiting'
WHERE id = p_game_id;
ELSE
UPDATE public.games
SET state = 'ready'
WHERE id = p_game_id;
END IF;
END;
$$;
-- Initiates the game start sequence
CREATE OR REPLACE FUNCTION public.start_game(game_code VARCHAR) RETURNS VOID LANGUAGE plpgsql AS $$
DECLARE v_game_id BIGINT;
v_current_state game_state;
BEGIN -- Fetch the game ID and current state
SELECT id,
    state INTO v_game_id,
    v_current_state
FROM public.games
WHERE code = game_code;
-- Ensure the game exists
IF NOT FOUND THEN RAISE EXCEPTION 'game-not-found';
END IF;
-- Verify the requester is the owner of the game
IF NOT EXISTS (
    SELECT 1
    FROM public.players
    WHERE user_id = auth.uid()
        AND game_id = v_game_id
        AND is_owner = TRUE
) THEN RAISE EXCEPTION 'only-owner-can-start';
END IF;
-- Ensure the game is in the 'ready' state
IF v_current_state != 'ready' THEN RAISE EXCEPTION 'game-not-ready';
END IF;
-- Update the game state to 'starting'
UPDATE public.games
SET state = 'starting'
WHERE id = v_game_id;
END;
$$;
-- Generates and records a dice roll for the current round
CREATE OR REPLACE FUNCTION public.roll_dice(p_game_id BIGINT) RETURNS INT LANGUAGE plpgsql AS $$
DECLARE dice_roll INT;
BEGIN -- Roll a dice (1-6)
dice_roll := CEIL(RANDOM() * 6)::INT;
-- Insert into game_rounds
INSERT INTO public.game_rounds (game_id, round, dice_roll)
VALUES (
        p_game_id,
        (
            SELECT COALESCE(MAX(round), 0) + 1
            FROM public.game_rounds
            WHERE game_id = p_game_id
        ),
        dice_roll
    );
RETURN dice_roll;
END;
$$;
-- ===========================================
-- GAMEPLAY FUNCTIONS
-- ===========================================
-- Records a player's starting position
CREATE OR REPLACE FUNCTION public.player_start(
        game_code VARCHAR,
        stop_id INT
    ) RETURNS VOID LANGUAGE plpgsql AS $$
DECLARE v_game_id BIGINT;
v_player_id BIGINT;
BEGIN -- Fetch game ID
SELECT id INTO v_game_id
FROM public.games
WHERE code = game_code;
-- Ensure the player exists
SELECT id INTO v_player_id
FROM public.players
WHERE user_id = auth.uid()
    AND game_id = v_game_id;
IF NOT FOUND THEN RAISE EXCEPTION 'player-not-found';
END IF;
-- Ensure the stop is marked as initial
IF NOT EXISTS (
    SELECT 1
    FROM public.stops
    WHERE id = stop_id
        AND initial = TRUE
) THEN RAISE EXCEPTION 'stop-not-valid-starting-position';
END IF;
-- Insert the starting stop as round 0
INSERT INTO public.player_moves (player_id, stop_id, round, game_id)
VALUES (v_player_id, stop_id, 0, v_game_id);
-- Check if the starting round is complete
PERFORM public.check_starting_round_completion(v_game_id);
END;
$$;
-- Processes a player's move and returns the drawn card
CREATE OR REPLACE FUNCTION public.player_move(
        game_code VARCHAR,
        game_round INT,
        stop_id INT
    ) RETURNS BIGINT LANGUAGE plpgsql AS $$
DECLARE v_game_id BIGINT;
v_player_id BIGINT;
stop_type stop_type;
stop_name VARCHAR(50);
drawn_card_id INT;
BEGIN -- Fetch game ID
SELECT id INTO v_game_id
FROM public.games
WHERE code = game_code;
-- Ensure the player exists
SELECT id INTO v_player_id
FROM public.players
WHERE user_id = auth.uid()
    AND game_id = v_game_id;
IF NOT FOUND THEN RAISE EXCEPTION 'player-not-found';
END IF;
-- Ensure the round exists
IF NOT EXISTS (
    SELECT 1
    FROM public.game_rounds
    WHERE game_id = v_game_id
        AND round = game_round
) THEN RAISE EXCEPTION 'round-not-found';
END IF;
-- Get the stop type and name
SELECT type,
    name INTO stop_type,
    stop_name
FROM public.stops
WHERE id = stop_id;
-- Draw a card based on stop type
IF stop_type = 'landmark' THEN -- For landmarks, find card with matching name
SELECT id INTO drawn_card_id
FROM public.cards
WHERE type = 'landmark'
    AND title = stop_name;
IF NOT FOUND THEN RAISE EXCEPTION 'no-matching-landmark-card-found';
END IF;
ELSE -- For other types, draw random card of matching type
SELECT id INTO drawn_card_id
FROM public.cards
WHERE type = stop_type
ORDER BY RANDOM()
LIMIT 1;
END IF;
-- Insert the player move
INSERT INTO public.player_moves (game_id, player_id, stop_id, round)
VALUES (v_game_id, v_player_id, stop_id, game_round);
-- Insert the drawn card
INSERT INTO public.player_cards (game_id, player_id, card_id, round)
VALUES (
        v_game_id,
        v_player_id,
        drawn_card_id,
        game_round
    );
RETURN drawn_card_id;
END;
$$;
-- Records a player's answer to a card
CREATE OR REPLACE FUNCTION public.player_answer(
        game_code VARCHAR,
        game_round INT,
        answer TEXT
    ) RETURNS VOID LANGUAGE plpgsql AS $$
DECLARE v_game_id BIGINT;
v_player_id BIGINT;
BEGIN -- Fetch game ID
SELECT id INTO v_game_id
FROM public.games
WHERE code = game_code;
-- Ensure the player exists
SELECT id INTO v_player_id
FROM public.players
WHERE user_id = auth.uid()
    AND game_id = v_game_id;
IF NOT FOUND THEN RAISE EXCEPTION 'player-not-found';
END IF;
-- Ensure the round exists
IF NOT EXISTS (
    SELECT 1
    FROM public.game_rounds
    WHERE game_id = v_game_id
        AND round = game_round
) THEN RAISE EXCEPTION 'round-not-found';
END IF;
-- Insert the player's answer
INSERT INTO public.player_answers (game_id, player_id, answer, round)
VALUES (
        v_game_id,
        v_player_id,
        answer,
        game_round
    );
-- Check if round is complete
PERFORM public.check_round_completion(v_game_id);
END;
$$;
-- Checks if the starting round is complete and updates game state
CREATE OR REPLACE FUNCTION public.check_starting_round_completion(p_game_id BIGINT) RETURNS VOID LANGUAGE plpgsql AS $$
DECLARE player_count INT;
move_count INT;
BEGIN -- Count total players in the game
SELECT COUNT(*) INTO player_count
FROM public.players
WHERE game_id = p_game_id;
-- Count starting round moves
SELECT COUNT(*) INTO move_count
FROM public.player_moves
WHERE game_id = p_game_id
    AND round = 0;
-- If all players have moved, set game state to playing
IF player_count = move_count THEN PERFORM public.roll_dice(p_game_id);
UPDATE public.games
SET state = 'playing'
WHERE id = p_game_id;
END IF;
END;
$$;
-- Checks if the current round is complete and updates game state
CREATE OR REPLACE FUNCTION public.check_round_completion(p_game_id BIGINT) RETURNS VOID LANGUAGE plpgsql AS $$
DECLARE current_round INT;
player_count INT;
answer_count INT;
BEGIN -- Get the current round number
SELECT COALESCE(MAX(round), 0) INTO current_round
FROM public.game_rounds
WHERE game_id = p_game_id;
-- Count total players in the game
SELECT COUNT(*) INTO player_count
FROM public.players
WHERE game_id = p_game_id;
-- Count answers for the current round
SELECT COUNT(*) INTO answer_count
FROM public.player_answers pa
    JOIN public.players p ON pa.player_id = p.id
WHERE p.game_id = p_game_id
    AND pa.round = current_round;
-- If all players have answered
IF player_count = answer_count THEN -- If this was the final round (6), set game state to finished
IF current_round >= 6 THEN
UPDATE public.games
SET state = 'finished'
WHERE id = p_game_id;
-- Otherwise, continue to next round
ELSE -- Roll dice for next round
PERFORM public.roll_dice(p_game_id);
END IF;
END IF;
END;
$$;